<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Cheat Sheets â€“ Rust</title>
  <link rel="stylesheet" href="/assets/css/style.css"/>
  <meta name="theme-color" content="#ffffff"/>
</head>
<body>
<header class="site">
  <div class="inner" style="display: flex; align-items: center;">
    <div class="logo"><img src="/assets/images/RUST/rust-logo.png" alt="Logo Rust" style="height: 40px;"></div>
    <div class="title" style="margin-left: 16px;">Cheat Sheets <small>â€“ AccÃ¨s rapide mobile</small></div>
  </div>
</header>

<!-- Boutons de navigation -->
<div class="nav-buttons">
  <a href="../home.html" class="btn btn-primary">
    â† Menu principal
  </a>
</div>

<div class="container">
  <h1>Rust</h1>
  <p>Rappel des concepts essentiels de Rust : syntaxe, types, ownership et bonnes pratiques.</p>

  <h2>ğŸš€ Projet Cargo</h2>
  <ul>
    <li><code>cargo new mon_projet</code> â†’ CrÃ©er un nouveau projet</li>
    <li><code>cargo build</code> â†’ Compiler le projet</li>
    <li><code>cargo run</code> â†’ Compiler et exÃ©cuter</li>
    <li><code>cargo check</code> â†’ VÃ©rifier sans compiler</li>
    <li><code>cargo build --release</code> â†’ Build optimisÃ© pour production</li>
  </ul>

  <h2>ğŸ“¦ Variables & MutabilitÃ©</h2>
  <ul>
    <li><code>let x = 5;</code> â†’ Variable immutable (par dÃ©faut)</li>
    <li><code>let mut x = 5;</code> â†’ Variable mutable</li>
    <li><code>const MAX: i32 = 100;</code> â†’ Constante (toujours typÃ©e)</li>
  </ul>
  <p><strong>Note :</strong> En Rust, les variables sont immutables par dÃ©faut. Utilise <code>mut</code> pour les modifier.</p>

  <h2>ğŸ”¢ Types de donnÃ©es</h2>
  <h3>Entiers</h3>
  <ul>
    <li><code>i8, i16, i32, i64, i128</code> â†’ Entiers signÃ©s</li>
    <li><code>u8, u16, u32, u64, u128</code> â†’ Entiers non signÃ©s (positifs)</li>
    <li><code>let age: i32 = 25;</code></li>
    <li><code>let count: u32 = 100;</code></li>
  </ul>

  <h3>Flottants</h3>
  <ul>
    <li><code>f32</code> â†’ Flottant 32 bits</li>
    <li><code>f64</code> â†’ Flottant 64 bits (dÃ©faut)</li>
    <li><code>let price: f64 = 19.99;</code></li>
  </ul>

  <h3>BoolÃ©ens & CaractÃ¨res</h3>
  <ul>
    <li><code>let is_active: bool = true;</code></li>
    <li><code>let lettre: char = 'A';</code></li>
  </ul>

  <h3>ChaÃ®nes de caractÃ¨res</h3>
  <ul>
    <li><code>let s: &str = "hello";</code> â†’ String slice (rÃ©fÃ©rence, immutable)</li>
    <li><code>let s: String = String::from("hello");</code> â†’ String (modifiable, heap)</li>
  </ul>

  <h2>ğŸ–¨ï¸ Affichage avec println!</h2>
  <ul>
    <li><code>println!("Hello");</code> â†’ Affiche du texte</li>
    <li><code>println!("x = {}", x);</code> â†’ Affiche une variable</li>
    <li><code>println!("{} + {} = {}", a, b, sum);</code> â†’ Plusieurs valeurs</li>
    <li><code>println!("{:?}", vecteur);</code> â†’ Debug print (pour tableaux/vecteurs)</li>
  </ul>
  <p><strong>Note :</strong> Le <code>!</code> indique que c'est une macro, pas une fonction.</p>

  <h2>ğŸ”€ Conditions</h2>
  <ul>
    <li><code>if condition { ... }</code></li>
    <li><code>if ... else { ... }</code></li>
    <li><code>if ... else if ... else { ... }</code></li>
  </ul>
  <p><strong>If comme expression :</strong></p>
  <ul>
    <li><code>let status = if age >= 18 { "adulte" } else { "mineur" };</code></li>
  </ul>

  <h2>ğŸ” Boucles</h2>
  <h3>Boucle for</h3>
  <ul>
    <li><code>for i in 0..5 { }</code> â†’ De 0 Ã  4 (5 exclus)</li>
    <li><code>for i in 0..=5 { }</code> â†’ De 0 Ã  5 (5 inclus)</li>
    <li><code>for elem in &vecteur { }</code> â†’ ItÃ©rer sur un vecteur</li>
  </ul>

  <h3>Boucle while</h3>
  <ul>
    <li><code>while condition { ... }</code></li>
  </ul>

  <h3>Boucle infinie</h3>
  <ul>
    <li><code>loop { ... break; }</code> â†’ Boucle infinie avec break pour sortir</li>
  </ul>

  <h2>âš™ï¸ Fonctions</h2>
  <ul>
    <li><code>fn ma_fonction() { }</code> â†’ Sans paramÃ¨tres ni retour</li>
    <li><code>fn add(a: i32, b: i32) -> i32 { a + b }</code> â†’ Avec retour implicite</li>
    <li><code>fn carre(x: i32) -> i32 { return x * x; }</code> â†’ Retour explicite</li>
    <li><code>fn afficher(nom: &str, age: i32) { }</code> â†’ Plusieurs paramÃ¨tres</li>
  </ul>
  <p><strong>Note :</strong> Sans <code>;</code> Ã  la fin, la derniÃ¨re expression est le retour implicite.</p>

  <h2>ğŸ“‹ Tableaux (Array)</h2>
  <p>Taille fixe, dÃ©finie Ã  la compilation.</p>
  <ul>
    <li><code>let arr: [i32; 5] = [1, 2, 3, 4, 5];</code></li>
    <li><code>arr[0]</code> â†’ AccÃ¨s au premier Ã©lÃ©ment</li>
    <li><code>arr.len()</code> â†’ Longueur du tableau</li>
  </ul>

  <h2>ğŸ“Š Vecteurs (Vec)</h2>
  <p>Taille dynamique, comme une liste.</p>
  <ul>
    <li><code>let mut v = vec![10, 20, 30];</code> â†’ CrÃ©er un vecteur</li>
    <li><code>v.push(40);</code> â†’ Ajouter un Ã©lÃ©ment</li>
    <li><code>v[1]</code> â†’ AccÃ©der Ã  l'index 1</li>
    <li><code>v.len()</code> â†’ Nombre d'Ã©lÃ©ments</li>
    <li><code>for n in &v { }</code> â†’ ItÃ©rer sur le vecteur</li>
  </ul>

  <h2>ğŸ” Ownership (PropriÃ©tÃ©)</h2>
  <p>Concept clÃ© de Rust pour la gestion mÃ©moire sans garbage collector.</p>

  <h3>RÃ¨gles</h3>
  <ul>
    <li>Chaque valeur a un propriÃ©taire unique</li>
    <li>Quand le propriÃ©taire sort du scope, la valeur est libÃ©rÃ©e</li>
  </ul>

  <h3>Move (DÃ©placement)</h3>
  <ul>
    <li><code>let s1 = String::from("hello");</code></li>
    <li><code>let s2 = s1;</code> â†’ s1 est dÃ©placÃ© vers s2, s1 n'est plus valide</li>
  </ul>

  <h3>Clone (Copie explicite)</h3>
  <ul>
    <li><code>let s2 = s1.clone();</code> â†’ Copie profonde, s1 reste valide</li>
  </ul>

  <h3>Copy (Types simples)</h3>
  <ul>
    <li>Les types simples (i32, f64, bool, char) sont copiÃ©s automatiquement</li>
    <li><code>let a = 5; let b = a;</code> â†’ a et b sont valides</li>
  </ul>

  <h2>ğŸ“ Borrowing (Emprunt)</h2>
  <p>Permet d'utiliser une valeur sans en prendre la propriÃ©tÃ©.</p>
  <ul>
    <li><code>&variable</code> â†’ RÃ©fÃ©rence immutable (lecture seule)</li>
    <li><code>&mut variable</code> â†’ RÃ©fÃ©rence mutable (lecture/Ã©criture)</li>
  </ul>
  <p><strong>RÃ¨gles :</strong></p>
  <ul>
    <li>Plusieurs rÃ©fÃ©rences immutables OK</li>
    <li>Une seule rÃ©fÃ©rence mutable Ã  la fois</li>
    <li>Pas de rÃ©fÃ©rence mutable si rÃ©fÃ©rences immutables existent</li>
  </ul>

  <h2>ğŸ“ Cargo.toml</h2>
  <p>Fichier de configuration du projet.</p>
  <ul>
    <li><code>[package]</code> â†’ Infos du projet (name, version, edition)</li>
    <li><code>[dependencies]</code> â†’ DÃ©pendances externes</li>
  </ul>
</div>

<footer class="site">Â© 2025 â€” Cheat Sheets statiques â€¢ DÃ©ployÃ© sur Netlify</footer>
<script src="/assets/js/copy.js" defer></script>
</body>
</html>
